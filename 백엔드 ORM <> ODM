## RM

**ORM**(Object-Relational Mapping)은 **객체-관계 매핑**을 의미합니다. 

이는 **객체지향 프로그래밍** 언어에서 다루는 **객체**와 **관계형 데이터베이스(RDBMS)**의 **테이블** 간의 변환을 자동으로 처리해주는 기술입니다.

### ORM의 주요 개념:

1. **객체와 테이블 매핑**:
    - 객체지향 프로그래밍 언어에서 사용하는 **객체**는 데이터베이스에서 사용하는 **테이블**의 행(row)과 매핑됩니다.
    - 예를 들어, **User**라는 클래스를 만들면, 이 클래스의 인스턴스는 데이터베이스의 **users** 테이블의 한 행에 대응됩니다.
2. **자동화된 SQL 쿼리 생성**:
    - ORM은 개발자가 SQL 쿼리를 직접 작성하지 않고, 객체를 **조작**함으로써 필요한 SQL을 자동으로 생성하고 실행합니다.
    - 예를 들어, 객체의 속성 값을 변경하거나, 객체를 추가/삭제/조회하면 ORM이 이를 SQL 쿼리로 변환하여 데이터베이스와 상호작용합니다.
3. **주요 기능**:
    - **CRUD (Create, Read, Update, Delete)**: 객체를 데이터베이스에 추가, 조회, 수정, 삭제하는 기본적인 작업을 쉽게 할 수 있게 도와줍니다.
    - **연관 관계 처리**: 객체 간의 **1:1, 1, N**관계를 쉽게 처리할 수 있습니다. 예를 들어, **User**와 **Post** 간의 관계를 매핑하여 두 객체 간의 연관을 자동으로 관리할 수 있습니다.

### ORM의 장점

- **코드 간결화**: SQL 쿼리를 일일이 작성할 필요 없이 객체 조작을 통해 데이터베이스 작업을 할 수 있어 코드가 간결해집니다.
- **보안**: SQL 인젝션 공격을 방지할 수 있습니다. ORM은 쿼리를 자동으로 생성하며, 파라미터화된 쿼리를 사용하여 보안을 강화합니다.
- **객체지향적 개발**: 객체지향 프로그래밍 언어에서 자연스럽게 데이터를 다룰 수 있게 해주어, 객체 모델과 관계형 모델 간의 변환을 손쉽게 할 수 있습니다.

### ORM의 단점

- **성능 저하**: 복잡한 쿼리나 대규모 데이터를 처리할 때 ORM이 생성하는 SQL이 비효율적일 수 있어 성능이 저하될 수 있습니다.
- **학습 곡선**: ORM 프레임워크를 처음 사용하는 개발자는 ORM의 개념과 사용법을 익히는 데 시간이 걸릴 수 있습니다.

## ODM

**ODM**은 **Object-Document Mapping**의 약자로, **객체-문서 매핑**을 의미합니다. 

**ODM**은 **비관계형 데이터베이스**(특히, MongoDB와 같은 **문서 지향 데이터베이스**)와 **객체지향 프로그래밍** 언어의 **객체** 간의 매핑을 처리하는 도구입니다. 

**ORM**(Object-Relational Mapping)이 관계형 데이터베이스(RDBMS)와 객체를 매핑하는 것처럼, 

**ODM**은 **문서**(Document) 형태로 데이터를 저장하고 관리하는 NoSQL 데이터베이스에서 **객체**와 **문서** 간의 변환을 다룹니다.

### 핵심 개념:

1. **객체-문서 매핑**:
    - *객체(Object)**는 프로그래밍 언어에서 다루는 데이터 단위입니다.
    - *문서(Document)**는 NoSQL 데이터베이스(특히 MongoDB)에서 데이터를 저장하는 단위입니다. 문서는 **JSON-like** 형식을 따르며, **key-value** 쌍으로 데이터를 저장합니다.
    - ODM은 **객체**와 **문서** 간의 변환을 처리해주는 라이브러리입니다.
2. **스키마 정의**:
    - ODM은 관계형 데이터베이스에서 사용하는 **테이블**처럼, NoSQL 데이터베이스에서 사용할 **문서의 구조**를 정의할 수 있게 합니다.
    - 예를 들어, Mongoose는 **스키마(Schema)**를 정의하여, MongoDB에서 사용할 데이터 구조를 설정합니다.
3. **객체와 데이터베이스 간 상호작용**:
    - **객체**를 사용하여 데이터를 **추가**, **수정**, **삭제**, **조회**할 수 있으며, 이 과정에서 **SQL 쿼리** 대신 **메서드**나 **객체**를 사용하여 데이터베이스와 상호작용합니다.
    - ODM은 내부적으로 **MongoDB 쿼리**를 자동으로 생성하고 실행합니다.

### ODM의 장점:

- **객체지향적 방식**으로 데이터베이스 작업을 할 수 있어, 코드가 더 직관적이고 관리하기 쉬워집니다.
- **SQL을 직접 작성하지 않고**, 고수준의 메서드를 사용하여 데이터베이스와 상호작용할 수 있습니다.
- **스키마 정의**와 데이터 검증 기능을 제공하여, MongoDB의 유연성을 유지하면서도 데이터 구조의 일관성을 관리할 수 있습니다.

### 대표적인 ODM 라이브러리:

- **Mongoose**: MongoDB를 위한 가장 널리 사용되는 ODM 라이브러리입니다.
- **Waterline**: Sails.js의 ODM, 다양한 데이터베이스와 호환됩니다.
- **Mongoist**: MongoDB의 더 간단한 API를 제공하는 ODM입니다.

## 차이점

### 차이점 요약:

1. **적용되는 데이터베이스**:
    - **ORM**은 **관계형 데이터베이스 (RDBMS)**와 상호작용합니다. 즉, **SQL**을 기반으로 한 데이터베이스(예: MySQL, PostgreSQL 등)에 사용됩니다.
    - **ODM**은 **비관계형 데이터베이스 (NoSQL)**, 특히 **문서 지향 데이터베이스**인 **MongoDB**와 상호작용합니다.
    
2. **데이터 모델링**:
    - **ORM**은 **테이블**과 **행(row)**을 객체로 매핑합니다. 각 **테이블**은 **클래스**로 정의되고, **행(row)**은 객체로 변환됩니다. 관계형 데이터베이스에서는 **조인**이나 **외래 키(foreign key)** 등 **테이블 간 관계**를 관리합니다.
    - **ODM**은 **문서(document)**와 **객체** 간의 매핑을 다룹니다. MongoDB는 데이터를 **JSON 형태의 문서**로 저장하므로, **문서**가 객체로 변환되고, 객체는 다시 문서 형태로 저장됩니다. MongoDB는 관계형 데이터베이스처럼 **조인**을 지원하지 않기 때문에, 관계 대신 **내장 문서(nested documents)** 또는 **참조(reference)** 방식을 사용합니다.
    
3. **쿼리 방식**:
    - **ORM**은 SQL 쿼리를 **자동 생성**하여 데이터베이스와 상호작용합니다. 객체 지향적으로 데이터를 다루는 메서드(`.save()`, `.find()`, `.update()`)를 호출하면 ORM이 내부적으로 SQL 쿼리를 생성합니다.
    - **ODM**도 마찬가지로 **메서드**를 호출하여 데이터를 조작하지만, 이 메서드들이 **MongoDB 쿼리**를 자동으로 생성하고 실행합니다. `find()`, `insert()`, `update()`와 같은 메서드는 SQL이 아니라 MongoDB의 쿼리 문법에 맞춰 동작합니다.

### 비교: ORM vs ODM

| **특징** | **ORM (Object-Relational Mapping)** | **ODM (Object-Document Mapping)** |
| --- | --- | --- |
| **적용 대상** | 관계형 데이터베이스(RDBMS) - 예: MySQL, PostgreSQL, SQLite 등 | 비관계형 데이터베이스(NoSQL) - 예: MongoDB |
| **데이터 저장 형태** | 테이블에 데이터를 행(row)로 저장 | 문서(document) 형식으로 데이터를 저장 |
| **데이터 모델링** | 테이블과 컬럼을 클래스로 매핑하고, 행을 객체로 변환 | 문서와 필드를 객체로 매핑하고, JSON-like 형태로 저장 |
| **주요 특징** | 데이터 간의 관계(조인, 외래 키 등)를 다룸 | 관계 없이 독립적인 문서로 데이터를 저장, 관계는 참조나 내장 문서로 처리 |
| **주로 사용되는 라이브러리** | **Sequelize**, **TypeORM**, **Hibernate** | **Mongoose** (MongoDB용) |
| **쿼리 방식** | SQL을 자동으로 생성하여 실행 | MongoDB 쿼리 문법을 자동으로 생성하여 실행 |
| **장점** | SQL 쿼리를 몰라도 객체지향적으로 데이터를 다룰 수 있음 | MongoDB와 같은 NoSQL 데이터베이스와 자연스럽게 연동됨 |
| **단점** | 관계형 데이터베이스의 제약에 맞춰 설계해야 하므로 더 많은 구조가 필요 | 스키마가 자유롭고 유연하지만, 데이터 일관성을 관리하기 어려움 |

### 결론:

- **ORM**과 **ODM**은 기본적으로 **객체지향 프로그래밍에서 데이터베이스와의 상호작용을 추상화**하는 도구로 비슷한 역할을 합니다.
- **ORM**은 관계형 데이터베이스(RDBMS)와, **ODM**은 비관계형 데이터베이스(NoSQL)와 함께 사용됩니다.
- 두 도구 모두 **SQL을 직접 작성하지 않고**, 객체 지향적인 방식으로 데이터베이스 작업을 처리할 수 있게 해줍니다.

따라서, 사용하는 **데이터베이스 유형**(관계형 vs 비관계형)에 따라 **ORM** 또는 **ODM**을 선택하게 됩니다.
